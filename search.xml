<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搭建Mysql主从服务（超详细）</title>
      <link href="/2020/05/07/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAMsyql%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/"/>
      <url>/2020/05/07/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAMsyql%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本地测试搭建Mysql主从服务，建议先安装测试好单个mysql服务，在进行主从配置。<em>Mysql主从服务也叫做<br>Replication、AB复制。简单理解，就是在数据库A（Master）中写入数据，数据库B（Slave）中会实时同步<br>数据。Mysql主从服务主要依赖于binlog，在Master上开启binlog后进行主从实时同步。</em>大概过程可以分为3<br>个步骤：1.主数据库(Master)将更改操作记录到binlog中。2.将Master的binlog事件(sql语句)同步本机上并记<br>录到relaylog里。3.从数据库(Slave)根据relaylog里面记录的sql语句顺序执行。</p><a id="more"></a><p>本地环境: win10<br>本地还没有安装过Mysql服务的话可以参考以下地址进行安装配置。<br><a href="https://www.cnblogs.com/laumians-notes/p/9069498.html" target="_blank" rel="noopener">https://www.cnblogs.com/laumians-notes/p/9069498.html</a><br>本文主要是针对已安装Mysql服务进行主从配置：</p><h3 id="1-停止第一个Mysql服务"><a href="#1-停止第一个Mysql服务" class="headerlink" title="1.停止第一个Mysql服务"></a>1.停止第一个Mysql服务</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开控制面试 -&gt;管理工具 -&gt; 打开本地服务 -&gt; 找到MYSQL,停止服务。</span><br></pre></td></tr></tbody></table></figure><h3 id="2-复制第一个MySQL服务的安装目录，并将新目录命名为mysql2"><a href="#2-复制第一个MySQL服务的安装目录，并将新目录命名为mysql2" class="headerlink" title="2.复制第一个MySQL服务的安装目录，并将新目录命名为mysql2"></a>2.复制第一个MySQL服务的安装目录，并将新目录命名为mysql2</h3><p><img src="https://i.loli.net/2020/05/07/h5HMzjnOmgWE71P.png" alt="image.png"></p><h3 id="3-编辑mysql2目录下的配置文件my-ini。修改配置文件中所有port的值，将第二个MySQL服务的端口改成3307。修改配置文件中basedir和datadir的值，改成指向第二个MySQL的安装目录的路径"><a href="#3-编辑mysql2目录下的配置文件my-ini。修改配置文件中所有port的值，将第二个MySQL服务的端口改成3307。修改配置文件中basedir和datadir的值，改成指向第二个MySQL的安装目录的路径" class="headerlink" title="3.编辑mysql2目录下的配置文件my.ini。修改配置文件中所有port的值，将第二个MySQL服务的端口改成3307。修改配置文件中basedir和datadir的值，改成指向第二个MySQL的安装目录的路径"></a>3.编辑mysql2目录下的配置文件my.ini。修改配置文件中所有port的值，将第二个MySQL服务的端口改成3307。修改配置文件中basedir和datadir的值，改成指向第二个MySQL的安装目录的路径</h3><ul><li><p>主服务器配置(my.ini):</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br><span class="line">basedir="D:/master/MySQL/"</span><br><span class="line">datadir="D:/master/MySQL/data/"</span><br><span class="line">character-set-server=utf8</span><br><span class="line">server_id=1</span><br><span class="line">log-bin=mysql-bin#要生成的二进制日记文件名称</span><br><span class="line">binlog-do-db=test#同步的数据库</span><br><span class="line">binlog-ignore-db=mysql#不参与同步的数据库 ，例如mysql</span><br></pre></td></tr></tbody></table></figure></li><li><p>从服务器配置(my.ini):</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port=3307</span><br><span class="line">basedir=D:\slave\mysql2</span><br><span class="line">datadir=D:\slave\mysql2\data</span><br><span class="line">server-id=2 </span><br><span class="line">log-bin=mysql-bin#开启了二进制文件</span><br><span class="line">binlog_do_db=follow#主从复制的数据库</span><br><span class="line">binlog_ignore_db=mysql#不参与主从复制的数据库，例如mysql</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="4-重新启动两个不同的mysql服务"><a href="#4-重新启动两个不同的mysql服务" class="headerlink" title="4.重新启动两个不同的mysql服务"></a>4.重新启动两个不同的mysql服务</h3><blockquote><p>这里有一个小坑（如下图所示）<br><img src="https://i.loli.net/2020/05/07/Y9vuryVm1XLKadj.png" alt="image.png"></p></blockquote><p>解决办法：在重新开启从库服务时需要先在命令行中运行(mysql的bin目录下)：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqld --initialize-insecure --user=root --basedir=D:\JAVA\mysql2 --datadir=D:\JAVA\mysql2\data</span><br></pre></td></tr></tbody></table></figure><p>然后再重新启动本地服务就可以正常启动了。</p><h3 id="5-使用root用户登录到主数据库-Master-中-创建勇于主从复制的用户并授权"><a href="#5-使用root用户登录到主数据库-Master-中-创建勇于主从复制的用户并授权" class="headerlink" title="5.使用root用户登录到主数据库(Master)中,创建勇于主从复制的用户并授权"></a>5.使用root用户登录到主数据库(Master)中,创建勇于主从复制的用户并授权</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'admin'</span>@<span class="string">'127.0.0.1'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'admin123'</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> . <span class="keyword">to</span> <span class="keyword">admin</span>@<span class="string">'127.0.0.1'</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在从服务器上用创建的用户登录主服务器，看能不能成功，成功继续下面的步骤</p></blockquote><blockquote><p>执行以下sql命令查看主服务器的bin-log日志文件名和position节点</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/05/07/g8PvLHaYJWMfkCF.png" alt="image.png"></p><h3 id="6-在从库中开启数据复制功能"><a href="#6-在从库中开启数据复制功能" class="headerlink" title="6.在从库中开启数据复制功能"></a>6.在从库中开启数据复制功能</h3><p>首先执行以下sql</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'127.0.0.1'</span>,master_port=<span class="number">3306</span>,master_user=<span class="string">'admin'</span>,master_password=<span class="string">'admin123'</span>,master_log_file=<span class="string">'mysql-bin.000001'</span>,master_log_pos=<span class="number">770</span>;</span><br></pre></td></tr></tbody></table></figure><p>执行成功后打开数据复制功能</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在从库可以通过show slave status \G来查看一些参数。<br><em>当Slave_IO_Running和Slave_SQL_Running线程都为yes是主从复制配置成功！</em></p></blockquote><blockquote><p>当Slave_IO_Running和Slave_SQL_Running线程有一个出现no的话都是不成的，这是可以通过show slave<br>status \G 来查看具体的报错信息后进行解决:例如场景的my.ini配置文件中的sever-id相同，网络不通等问<br>题通常会导致IO出错，SQL线程出错也会有相应的数据库表不存在等报错信息给出。都可以按需进行解决。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql主从 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaCV 序章</title>
      <link href="/2020/04/24/javaCV/"/>
      <url>/2020/04/24/javaCV/</url>
      
        <content type="html"><![CDATA[<p>以前从来不觉得java可以做流媒体、音视频编解码这些，直到现在，顶多说java做流媒体是非主流。业界广泛应用的librtmp、live555、ffmpeg也都是c/c++的库，刚开始也确实尝试过使用jni方式调ffmpeg，发现做起来吃力不讨好，后来在github发现了新大陆：javaCV。</p><h3 id="JavaCV大法"><a href="#JavaCV大法" class="headerlink" title="JavaCV大法"></a>JavaCV大法</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 站在巨人肩膀上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java流媒体技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System.currentTimeMillis() 的潜在性能问题</title>
      <link href="/2020/04/07/System.currentTimeMillis()%20%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/07/System.currentTimeMillis()%20%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>System.currentTimeMillis()是极其常用的基础Java API，广泛地<em>用来获取时间戳或测量代码执行时长</em>等，在我们的印象中应该快如闪电。但实际上在并发调用或者特别频繁调用它的情况下（比如一个业务繁忙的接口，或者吞吐量大的需要取得时间戳的流式程序），其性能表现会令人大跌眼镜。</p><a id="more"></a><h3 id="先来看一段程序"><a href="#先来看一段程序" class="headerlink" title="先来看一段程序"></a>先来看一段程序</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentTimeMillisPerfDemo</span> </span>{</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="keyword">long</span> beginTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) {</span><br><span class="line">System.currentTimeMillis();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">long</span> elapsedTime = System.nanoTime() - beginTime;</span><br><span class="line">System.out.println(<span class="string">"100 System.currentTimeMillis() serial calls: "</span> + elapsedTime + <span class="string">" ns"</span>);</span><br><span class="line"></span><br><span class="line">CountDownLatch startLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">CountDownLatch endLatch = <span class="keyword">new</span> CountDownLatch(COUNT);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) {</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">startLatch.await();</span><br><span class="line">System.currentTimeMillis();</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">endLatch.countDown();</span><br><span class="line">}</span><br><span class="line">}).start();</span><br><span class="line">}</span><br><span class="line">beginTime = System.nanoTime();</span><br><span class="line">startLatch.countDown();</span><br><span class="line">endLatch.await();</span><br><span class="line">elapsedTime = System.nanoTime() - beginTime;</span><br><span class="line">System.out.println(<span class="string">"100 System.currentTimeMillis() parallel calls: "</span> + elapsedTime + <span class="string">" ns"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果如下：</p><p><img src="https://i.loli.net/2020/04/07/wvRJuzhl63LyIbE.jpg" alt="result"></p><p>可见，并发调用System.currentTimeMillis()一百次，耗费的时间是单线程调用一百次的250倍。如果单线程的调用频次增加（比如达到每毫秒数次的地步），也会观察到类似的情况。实际上在极端情况下，System.currentTimeMillis()的耗时甚至会比创建一个简单的对象实例还要多。</p><h3 id="为什么会这样？"><a href="#为什么会这样？" class="headerlink" title="为什么会这样？"></a>为什么会这样？</h3><p>来到HotSpot源码的hotspot/src/os/linux/vm/os_linux.cpp文件中，有一个javaTimeMillis()方法，这就是System.currentTimeMillis()的native实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jlong os::javaTimeMillis() {</span><br><span class="line">timeval time;</span><br><span class="line"><span class="keyword">int</span> status = gettimeofday(&amp;time, NULL);</span><br><span class="line"><span class="keyword">assert</span>(status != -<span class="number">1</span>, <span class="string">"linux error"</span>);</span><br><span class="line"><span class="keyword">return</span> jlong(time.tv_sec) * <span class="number">1000</span> + jlong(time.tv_usec / <span class="number">1000</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简单来讲就是：</p><ul><li>调用gettimeofday()需要从用户态切换到内核态；</li><li>gettimeofday()的表现受Linux系统的计时器（时钟源）影响，在HPET计时器下性能尤其差；</li><li>系统只有一个全局时钟源，高并发或频繁访问会造成严重的争用。</li></ul><p>HPET计时器性能较差的原因是会将所有对时间戳的请求串行执行。TSC计时器性能较好，因为有专用的寄存器来保存时间戳。缺点是可能不稳定，因为它是纯硬件的计时器，频率可变（与处理器的CLK信号有关）。</p><h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentTimeMillisClock</span> </span>{</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> now;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CurrentTimeMillisClock</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.now = System.currentTimeMillis();</span><br><span class="line">scheduleTick();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleTick</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, runnable -&gt; {</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">"current-time-millis"</span>);</span><br><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">}).scheduleAtFixedRate(() -&gt; {</span><br><span class="line">now = System.currentTimeMillis();</span><br><span class="line">}, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">now</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CurrentTimeMillisClock <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>{</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CurrentTimeMillisClock INSTANCE = <span class="keyword">new</span> CurrentTimeMillisClock();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用的时候，直接 CurrentTimeMillisClock.getInstance().now()就可以了。</p><p>不过，在System.currentTimeMillis()的效率没有影响程序整体的效率时，就完全没有必要做这种优化，这只是为极端情况准备的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做好数据埋点</title>
      <link href="/2019/12/11/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9/"/>
      <url>/2019/12/11/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据埋点，对于产品，研发，运营人员都不算陌生。数据埋点让我们以极低的成本快速获取有益的时效数据。<br>本文中笔者高屋建瓴，又以清晰的叙述思路向我们介绍了常用埋点方案，我们可以一起来仔细看看。<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p></blockquote><a id="more"></a><p><img src="https://i.loli.net/2019/12/12/FAfW2sdLB4J7tV9.jpg" alt="maidian.jpg"></p><h3 id="一、埋点技术"><a href="#一、埋点技术" class="headerlink" title="一、埋点技术"></a>一、埋点技术</h3><p>代码埋点：</p><p>所谓的代码埋点就是在你需要统计数据的地方植入N行代码，统计用户的关键行为。比如你想统计首页某个banner的点击量，上报的数据可以采用KEY-VALUE形式，我们定义KEY为「CLICK_ADD_BTN」，VALUE的值为点击的次数。当用户点击banner时，banner详情的代码会通过按钮的「回调」来触发执行，程序猿在业务代码执行完后，又加上了统计代码，把「CLICK_ADD_BTN」对应的VALUE加1，banner被统计到了一次使用。</p><p>代码埋点的优点：</p><ol><li>使用者控制精准，可以非常精确地选择什么时候发送数据</li><li>使用者可以比较方便地设置自定义属性、自定义事件，传递比较丰富的数据到服务端。</li></ol><p>代码埋点的缺点：</p><ol><li>埋点代价比较大，每一个控件的埋点都需要添加相应的代码，不仅工作量大，而且限定了必须是技术人员才能完成；</li><li>更新代价比较大，每一次更新，都需要更新埋点方案，然后通过各个应用市场进行分发，而且有的用户还不一定更新，这样你就获取不到这批用户数据。</li></ol><p>可视化埋点：</p><p>既然代码埋点代价比较大，每一个埋点都需要写代码，那就使用可视化交互手段代替写代码；既然每次代码埋点都需要更新，那就参照现在的很多手游做法，把核心代码和配置、资源分开，每次用户启动app的时候通过网络更新配置和资源。</p><p>可视化埋点优势：</p><p>可视化买点解决了代码埋点埋点代价大和更新代价大两个问题。</p><p>可视化埋点劣势：</p><p>可视化埋点能够覆盖的功能有限，目前并不是所有的控件操作都可以通过这种方案进行定制；</p><p>无埋点：</p><p>可视化埋点先通过界面配置哪些控件的操作数据需要收集；“无埋点”则是先尽可能收集所有控件的操作数据，然后再通过界面配置哪些数据需要在系统里面进行分析，“无埋点”也就是“全埋点”的意思。</p><p>无埋点的优点：</p><p>可视化埋点只能收集到你埋点以后的数据，如果你想对某个按钮进行点击分析，则只能分析增加可视化埋点以后的数据，之前的数据你收集不到，而无埋点在你部署SDK的时候数据就一直在收集。</p><p>因为无埋点对页面所有元素进行埋点，那么这个页面每个元素被点击的概率你也就知道，对点击概率比较大的元素可以进行深入分析。</p><p>无埋点的缺点：</p><p>由于无埋点方案所有的元素数据都收集，会给数据传输和服务器带来较大的压力。</p><h3 id="二、数据埋点方式"><a href="#二、数据埋点方式" class="headerlink" title="二、数据埋点方式"></a>二、数据埋点方式</h3><ol><li>公司研发在自己的产品当中注入统计代码，搭建相应的后台查询，这种代价比较大。</li><li>集成第三方统计的SDK，比如友盟、百度移动统计、Sensors Data、GrowingIO、Talking Data等。</li></ol><h3 id="三、如何进行数据埋点"><a href="#三、如何进行数据埋点" class="headerlink" title="三、如何进行数据埋点"></a>三、如何进行数据埋点</h3><ol><li>明确目标</li></ol><p>经常有人问我说我要获取那些数据来进行数据分析，其实这个问题不应该问别人，应该问问你自己，你是想用这个数据干什么，如果你想绘制基础的人群画像你就需要获取用户机型、网络类型、操作系统，IP地域等数据；如果你想分析每一个注册转化率，你就需要获取每一个步骤的点击次数，然后制作成漏斗，看那一步转化率出现了问题；目的不一样，获取的数据也不一样，使用的埋点技术也不一样，我们无论做什么事情都不能忘了我们的目的！</p><ol start="2"><li>获取相应数据</li></ol><p>业务不同，目的不同获取的数据也不同，这里我只说一些比较共性的数据。</p><p>2.1 产品各个渠道下载量</p><p>这个可以用第三方数据统计工具来进行，这样我们可以知道我们产品着重在那个渠道进行推广。</p><p>2.2 产品活跃状态分析</p><p>产品活跃状态监控，留存分析、流失分析、新增变化等，次日留存率、七日留存率、月留存率，尤其对于处于成长期的产品而已，这个指标很重要，如果留存率比较低，说明你的产品有问题，这个时候你就需要进行用户调研，找到流失的问题，否则大面积拉新，只能拉多少死多少，至于留存率、新增的变化这些数据，我们也可以借助第三方统计工具来进行。</p><p>2.3 事件分析</p><p>比如你想统计某个页面的Uv、PV、元素的点击量、用户停留时长、页面跳出率等数据指标，可以选择代码埋点和可视化埋点等前端埋点解决方案。当某个页面的UV很高，但是跳出率也很高，说明页面有问题，你就要好好想想页面的问题出在什么地方。</p><p>2.4 基本信息获取</p><p>基本信息获取，例如机型、网络类型、操作系统，IP地域等，绘制基础用户人群画像，这种分析出来的用户画像颗粒度比较大，如果想更精准的进行用户画像可以结合推荐系统，来获取用户的兴趣指标，以及用户操作行为等数据来进行更精准的用户画像，从而为产品运营和产品设计提供参考，可以借助第三方统计工具和自定义埋点的方式进行数据的收集。</p><p>2.5 漏斗模型</p><p>对于产品的关键路径一定要进行漏斗模型分析，比如注册路径，从用户输入注册手机号到注册成功，中间可能会有几个步骤，如果100个人注册，最后只有一个人注册成功，那么求运营同学心里的阴影面积。还有电商的购买下单路径，从浏览商品到最后下单购买成功，每一个步骤的转化率是多少，对于漏的比较多的那个步骤我们肯定要着重关注，分析原因。这个可以技术研发进行埋点，获取更精确的数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据埋点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 来源：四姑娘山的稻城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊微服务与分布式</title>
      <link href="/2019/11/18/%E8%81%8A%E4%B8%80%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2019/11/18/%E8%81%8A%E4%B8%80%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>微服务是一种面向服务的架构(SOA)风格（Java开发人员最重要的技能之一），其中，应用程序被构建为多个不同的小型服务的集合而不是单个应用程序。</p><a id="more"></a><h3 id="一、什么是微服务"><a href="#一、什么是微服务" class="headerlink" title="一、什么是微服务?"></a>一、什么是微服务?</h3><p>与单个程序不同的是，微服务让你可以同时运行多个独立的应用程序，而这些独立的应用程序可以使用不同的编码或编程语言来创建。庞大而又复杂的应用程序可以由多个可自行执行的简单而又独立的程序所组成。这些较小的程序组合在一起，可以提供庞大的单程序所具备的所有功能。</p><p>微服务是一种面向服务的架构风格,具有灵活性和低成本两个特点.</p><ol><li><p>灵活性:由于这些较小的应用程序无需使用相同的编程语言,因此,开发人员可以使用他们最熟悉的语言,这是灵活性.</p></li><li><p>低成本:由于他们都用自己擅长的语言去开发,所以效率会高,相应的开发成本会降低.</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java排坑指南(非公开版)</title>
      <link href="/2019/11/14/Java%E6%8E%92%E5%9D%91%E6%8C%87%E5%8D%97-%E9%9D%9E%E5%85%AC%E5%BC%80%E7%89%88/"/>
      <url>/2019/11/14/Java%E6%8E%92%E5%9D%91%E6%8C%87%E5%8D%97-%E9%9D%9E%E5%85%AC%E5%BC%80%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>这里记录一个排坑清单，我们没有必要纠结什么对，什么是错。但我们有必要知道什么是优，什么是劣。 </p><p>以下奉上满汉坑单一张（不定期更新排雷进度）</p><a id="more"></a><h3 id="1-尽量使用Collection-isEmpty-检测空"><a href="#1-尽量使用Collection-isEmpty-检测空" class="headerlink" title="1. 尽量使用Collection.isEmpty()检测空"></a>1. 尽量使用Collection.isEmpty()检测空</h3><p>使用Collection.size()来检测空在逻辑上没有问题，但是使用Collection.isEmpty()使得代码更易读，<br>并且可以获得更好的性能。</p><p>任何Collection.isEmpty()实现的时间复杂度都是O(1),但是某些Collection.size()实现的时间复杂度是O(n)。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(collection.size() == <span class="number">0</span>){}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(collection.isEmpty()){}</span><br></pre></td></tr></tbody></table></figure><p>判空：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CollectionUtils.isEmpty(collection)</span><br><span class="line">CollectionUtils.isNotEmpty(collection)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-集合初始化尽量指定大小"><a href="#2-集合初始化尽量指定大小" class="headerlink" title="2. 集合初始化尽量指定大小"></a>2. 集合初始化尽量指定大小</h3><p>Java 的集合类用起来十分方便，但是看源码可知，集合也是有大小限制的。每次扩容的时间复杂度很有可能是<br>O(n),所以尽量指定可预知的集合大小，能减少集合的扩容次数。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {</span><br><span class="line">    list.add(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(arr.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {</span><br><span class="line">    list.add(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-Tip-可以使用ONDUPLICATE-KEY-UPDATE-和唯一索引实现SQL批量插入更新操作"><a href="#3-Tip-可以使用ONDUPLICATE-KEY-UPDATE-和唯一索引实现SQL批量插入更新操作" class="headerlink" title="3. [Tip]可以使用ONDUPLICATE KEY UPDATE 和唯一索引实现SQL批量插入更新操作"></a>3. [Tip]可以使用ONDUPLICATE KEY UPDATE 和唯一索引实现SQL批量插入更新操作</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id="insertOrUpdateCameraInfoByOne" paramerType="com.pojo.AreaInfo"&gt;</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> camera_info( cameraId,zone1Id,zone1Name,zone2Id,zone2Name,zone3Id,zone3Name,zone4Id,zone4Name）</span><br><span class="line">    <span class="keyword">VALUES</span>(</span><br><span class="line">        <span class="comment">#{cameraId},#{zone1Id},#{zone1Name}, #{zone2Id},</span></span><br><span class="line">        <span class="comment">#{zone2Name}, #{zone3Id}, #{zone3Name},</span></span><br><span class="line">        <span class="comment">#{zone4Id}, #{zone4Name},)</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> </span><br><span class="line">    cameraId = <span class="keyword">VALUES</span>(cameraId),</span><br><span class="line">    zone1Id = <span class="keyword">VALUES</span>(zone1Id),zone1Name = <span class="keyword">VALUES</span>(zone1Name),</span><br><span class="line">    zone2Id = <span class="keyword">VALUES</span>(zone2Id),zone2Name = <span class="keyword">VALUES</span>(zone2Name),</span><br><span class="line">    zone3Id = <span class="keyword">VALUES</span>(zone3Id),zone3Name = <span class="keyword">VALUES</span>(zone3Name),</span><br><span class="line">    zone4Id = <span class="keyword">VALUES</span>(zone4Id),zone4Name = <span class="keyword">VALUES</span>(zone4Name)</span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="4-不要把集合对象传给自己"><a href="#4-不要把集合对象传给自己" class="headerlink" title="4. 不要把集合对象传给自己"></a>4. 不要把集合对象传给自己</h3><p>由于某些方法要求参数在执行期间保持不变，因此将集合传递给自身可能会导致异常行为。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br><span class="line">list.add(<span class="string">"World"</span>);</span><br><span class="line"><span class="keyword">if</span> (list.containsAll(list)) {}<span class="comment">// 无意义,总是返回true</span></span><br><span class="line">list.removeAll(list); <span class="comment">// 性能差, 直接使用clear()</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-字符串拼接使用-StringBuilder"><a href="#5-字符串拼接使用-StringBuilder" class="headerlink" title="5. 字符串拼接使用 StringBuilder"></a>5. 字符串拼接使用 StringBuilder</h3><p>一般的字符串拼接在编译期 java 会进行优化，但是在循环中字符串拼接， java 编译期无法做到<br>优化，所以需要使用 StringBuilder 进行替换。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">    s += i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line">String c = <span class="string">"c"</span>;</span><br><span class="line">String s = a + b + c; <span class="comment">// 没问题，java编译器会进行优化</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">    sb.append(i);  <span class="comment">// 循环中，java编译器无法进行优化，所以要手动使用StringBuilder</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6-枚举的属性字段必须是私有不可变"><a href="#6-枚举的属性字段必须是私有不可变" class="headerlink" title="6. 枚举的属性字段必须是私有不可变"></a>6. 枚举的属性字段必须是私有不可变</h3><p>枚举通常被当做常量使用，如果枚举中存在公共属性字段或设置字段方法，那么这些枚举常量的属性很容易被修改。<br>理想情况下，枚举中的属性字段是私有的，并在私有构造函数中赋值，没有对应的 Setter 方法，最好加上 final 修饰符。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserStatus {</span><br><span class="line">    DISABLED(<span class="number">0</span>, <span class="string">"禁用"</span>),</span><br><span class="line">    ENABLED(<span class="number">1</span>, <span class="string">"启用"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserStatus</span><span class="params">(<span class="keyword">int</span> value, String description)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserStatus {</span><br><span class="line">    DISABLED(<span class="number">0</span>, <span class="string">"禁用"</span>),</span><br><span class="line">    ENABLED(<span class="number">1</span>, <span class="string">"启用"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserStatus</span><span class="params">(<span class="keyword">int</span> value, String description)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-小心String-split-String-regex"><a href="#7-小心String-split-String-regex" class="headerlink" title="7. 小心String.split(String regex)"></a>7. 小心String.split(String regex)</h3><p>字符串 String 的 split 方法，传入的分隔字符串是<strong>正则表达式</strong>！部分关键字（比如.<a href=""></a>| 等）需要转义</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a.ab.abc"</span>.split(<span class="string">"."</span>); <span class="comment">// 结果为[]</span></span><br><span class="line"><span class="string">"a|ab|abc"</span>.split(<span class="string">"|"</span>); <span class="comment">// 结果为["a", "|", "a", "b", "|", "a", "b", "c"]</span></span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a.ab.abc"</span>.split(<span class="string">"\\."</span>); <span class="comment">// 结果为["a", "ab", "abc"]</span></span><br><span class="line"><span class="string">"a|ab|abc"</span>.split(<span class="string">"\\|"</span>); <span class="comment">// 结果为["a", "ab", "abc"]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="8-Tip-Java-9改进了String、StringBuffer、StringBuilder"><a href="#8-Tip-Java-9改进了String、StringBuffer、StringBuilder" class="headerlink" title="8. [Tip] Java 9改进了String、StringBuffer、StringBuilder"></a>8. [Tip] Java 9改进了String、StringBuffer、StringBuilder</h3><p>Java 提供String、StringBuffer、StingBuilder 封装字符串</p><p>String类是不可变类，String对象被创建后，包含在这个对象的字符序列不可改变</p><p>StringBuffer 对象代表一个字符序列可变的字符串，创建后通过append()、insert()等方法改变字符序列，最后调用<br>toString() 方法转换为String对象</p><p>StringBuilder也代表可变字符串对象，与StringBuffer区别在于StringBuffer线程安全，StringBuilder没有实现<br>线程安全，所以性能略高。</p><p>Java 9 改进了字符串的实现，之前使用char[] 保存字符，Java 9 改用Byte[]<strong>更加节省空间</strong>。</p><blockquote><p>字符串拼接原理：运行时,两个字符串str1,str2的拼接首先会调用 String.valueOf(obj),这个Obj为str1,而<br>String.valueOf(Obj)中的实现是return obj == null ? “null” : obj.toString(), 然后产生StringBuilder,调<br>用的StringBuilder(str1)构造方法,把StringBuilder初始化,长度为str1.length()+16,并且调用append(str1)！接<br>下来调用StringBuilder.append(str2)，把第二个字符串拼接进去,然后调用StringBuilder.toString返回结果！</p></blockquote><h3 id="9-需要-Map-的主键和取值时，应该迭代-entrySet"><a href="#9-需要-Map-的主键和取值时，应该迭代-entrySet" class="headerlink" title="9. 需要 Map 的主键和取值时，应该迭代 entrySet()"></a>9. 需要 Map 的主键和取值时，应该迭代 entrySet()</h3><p>当循环中只需要 Map 的主键时，迭代 keySet() 是正确的。<br>但是，当需要主键和取值时，迭代 entrySet() 才是更高效的做法，比先迭代 keySet() 后再去 get 取值性能更佳。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ...;</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) {</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ...;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="10-集合初始化尽量指定大小"><a href="#10-集合初始化尽量指定大小" class="headerlink" title="10. 集合初始化尽量指定大小"></a>10. 集合初始化尽量指定大小</h3><p>java 的集合类用起来十分方便，但是看源码可知，集合也是有大小限制的。<br>每次扩容的时间复杂度很有可能是 O(n) ，所以尽量指定可预知的集合大小，能减少集合的扩容次数。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {</span><br><span class="line">    list.add(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(arr.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {</span><br><span class="line">    list.add(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="11-List-的随机访问"><a href="#11-List-的随机访问" class="headerlink" title="11. List 的随机访问"></a>11. List 的随机访问</h3><p>大家都知道数组和链表的区别：数组的随机访问效率更高。</p><p>当调用方法获取到 List 后，如果想随机访问其中的数据，并不知道该数组内部实现是链表还是数组，怎么办呢？<br>可以判断它是否实现* RandomAccess 接口。</p><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用别人的服务获取到list</span></span><br><span class="line">List&lt;Integer&gt; list = otherService.getList();</span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) {</span><br><span class="line">    <span class="comment">// 内部数组实现，可以随机访问</span></span><br><span class="line">    System.out.println(list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 内部可能是链表实现，随机访问效率低</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="12-频繁调用-Collection-contains-方法请使用-Set"><a href="#12-频繁调用-Collection-contains-方法请使用-Set" class="headerlink" title="12. 频繁调用 Collection.contains 方法请使用 Set"></a>12. 频繁调用 Collection.contains 方法请使用 Set</h3><p>在 java 集合类库中，List 的 contains 方法普遍时间复杂度是 O(n)<br>如果在代码中需要频繁调用 contains 方法查找数据，可以先将 list 转换成 HashSet 实现，将 O(n) 的时间复杂度降为 O(1) 。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = otherService.getList();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) {</span><br><span class="line">    <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line">    list.contains(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = otherService.getList();</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet(list);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) {</span><br><span class="line">    <span class="comment">// 时间复杂度O(1)</span></span><br><span class="line">    set.contains(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="13-不要使用魔法值"><a href="#13-不要使用魔法值" class="headerlink" title="13. 不要使用魔法值"></a>13. 不要使用魔法值</h3><p>当你编写一段代码时，使用魔法值可能看起来很明确，但在调试时它们却不显得那么明确了。<br>这就是为什么需要把魔法值定义为可读取常量的原因。但是，-1、0 和 1不被视为魔法值</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++){</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">100</span>) {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i++){</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (count == MAX_COUNT) {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="14-建议使用-try-with-resources-语句"><a href="#14-建议使用-try-with-resources-语句" class="headerlink" title="14. 建议使用 try-with-resources 语句"></a>14. 建议使用 try-with-resources 语句</h3><p>Java 7 中引入了 try-with-resources 语句，该语句能保证将相关资源关闭，优于原来的 try-catch-finally 语句，并且使程序代码更安全更简洁。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String fileName)</span> </span>{</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        String line;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                reader.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                ...</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String fileName)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) {</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Ref: <a href="https://www.cnblogs.com/yueshutong/p/10725477.html" target="_blank" rel="noopener">https://www.cnblogs.com/yueshutong/p/10725477.html</a></p><h3 id="15-建议删除未使用的私有方法和字段"><a href="#15-建议删除未使用的私有方法和字段" class="headerlink" title="15. 建议删除未使用的私有方法和字段"></a>15. 建议删除未使用的私有方法和字段</h3><p>删除未使用的私有方法和字段，使代码更简洁更易维护。若有需要再使用，可以从历史提交中找回。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleDemo1</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> unusedField = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unusedMethod</span><span class="params">()</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleDemo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>代码膨胀</strong>是稍微有点规模的项目都会遇到的问题，在《人月神话》中也有提及。有规模的工程项目都是团队的产<br>物，既然是团队的产物，那么不可能不存在重复的代码，而这种重复的代码随着团队人员的增多，代码规模的增<br>加会更加的突出。这是一个必然存在的问题，不管是你的团队成员多么的优秀，规模的工程项目必然会存在，只<br>不过是优秀的团队使得这种重复和混乱的增长速度变得小了而已。</p></blockquote><h3 id="16-工具类应该屏蔽构造函数"><a href="#16-工具类应该屏蔽构造函数" class="headerlink" title="16. 工具类应该屏蔽构造函数"></a>16. 工具类应该屏蔽构造函数</h3><p>工具类是一堆静态字段和函数的集合，不应该被实例化。但是，Java 为每个没有明确定义构造函数的类添加了一个隐式公有构造函数。<br>所以，为了避免 java “小白”使用有误，应该显式定义私有构造函数来屏蔽这个隐式公有构造函数。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>D;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>D;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MathUtils</span><span class="params">()</span> </span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="17-删除多余的异常捕获并抛出"><a href="#17-删除多余的异常捕获并抛出" class="headerlink" title="17. 删除多余的异常捕获并抛出"></a>17. 删除多余的异常捕获并抛出</h3><p>用 catch 语句捕获异常后，什么也不进行处理，就让异常重新抛出，这跟不捕获异常的效果一样，可以删除这块代码或添加别的处理。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) {</span><br><span class="line">        String line;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            builder.append(line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) {</span><br><span class="line">        String line;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            builder.append(line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="18-使用String-valueOf-value-代替””-value"><a href="#18-使用String-valueOf-value-代替””-value" class="headerlink" title="18. 使用String.valueOf(value)代替””+value"></a>18. 使用String.valueOf(value)代替””+value</h3><p>当要把其它对象或类型转化为字符串时，使用 String.valueOf(value) 比””+value 的效率更高。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">String s = <span class="string">""</span> + i;</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">String s = String.valueOf(i);</span><br></pre></td></tr></tbody></table></figure><h3 id="19-优先使用常量或确定值来调用-equals-方法"><a href="#19-优先使用常量或确定值来调用-equals-方法" class="headerlink" title="19. 优先使用常量或确定值来调用 equals 方法"></a>19. 优先使用常量或确定值来调用 equals 方法</h3><p>对象的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals 方法。当然，使用<br>java.util.Objects.equals() 方法是最佳实践。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isFinished</span><span class="params">(OrderStatus status)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> status.equals(OrderStatus.FINISHED); <span class="comment">// 可能抛空指针异常</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isFinished</span><span class="params">(OrderStatus status)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> OrderStatus.FINISHED.equals(status);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isFinished</span><span class="params">(OrderStatus status)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(status, OrderStatus.FINISHED);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Best Ref: <a href="https://mp.weixin.qq.com/s/1aAwroGRSGWrzgE6XpPx7Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1aAwroGRSGWrzgE6XpPx7Q</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB架构演进之路</title>
      <link href="/2019/11/13/WEB%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/11/13/WEB%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>机械制图的时候，通常使用三视图来描述一个机械零件，分别从正视、侧视、俯视三个角度对一个零件绘图，从而全面描述一个零件的结构。软件架构设计中常用的是4+1试图模型。</p><a id="more"></a><blockquote><p>多角度架构描述方法：1. 从演化、模式、要素三个维度描述网站整体架构2. 从性能、可用性、伸缩性、扩展性、安全这五个要素描述网站架构3. 从整体和局部描述网站架构方法4. 从架构师做事的角度回顾网站技术架构 </p></blockquote><p>大型互联网应用系统特点：</p><ol><li>高并发、大流量: 谷歌日均PV35亿 </li><li>高可用: 7乘24不间断服务</li><li>海量数据: Facebook每周上传照片10亿</li><li>用户分布广，网络复杂: 为全球用户提供服务</li><li>安全环境恶劣: 大型网站几乎没听都会被黑客攻击</li><li>需求快速变更，发布频繁: Office每年发布，大型网站每周发布，中小型网站一天发布几十次</li><li>渐进式发展: 好的互联网产品都是慢慢运营出来的</li></ol><h3 id="1-初始网站架构："><a href="#1-初始网站架构：" class="headerlink" title="1 初始网站架构："></a>1 初始网站架构：</h3><p><img src="http://pztbc1npk.bkt.clouddn.com/arch1.png" alt="arch1"><br>应用程序、数据库、文件等所有资源都在一台服务器上</p><h3 id="2-应用服务和数据服务分离"><a href="#2-应用服务和数据服务分离" class="headerlink" title="2 应用服务和数据服务分离"></a>2 应用服务和数据服务分离</h3><p>应用和数据分离后整个网站使用三台服务器：应用服务器、文件服务器和数据库服务器<br>应用服务器主要处理大量业务逻辑：需要更强大CPU<br>数据服务器：需要更快速的磁盘检索和数据缓存<br>文件服务器需要存储大量用户上传的文件：需要更大的硬盘<br><img src="http://pztbc1npk.bkt.clouddn.com/arch2.png" alt="arch2"></p><p>并发处理能力和数据存储空间得到改善，但是随着用户逐渐增多，数据库压力增加导致访问延迟</p><h3 id="3-使用缓存提高性能"><a href="#3-使用缓存提高性能" class="headerlink" title="3 使用缓存提高性能"></a>3 使用缓存提高性能</h3><p>网站范文遵循二八定律：80%的业务访问集中在20%数据上。<br>缓存方式：</p><ol><li>缓存在应用服务器上的本地缓存：受本身内存限制，缓存数量有限</li><li>缓存在专门的分布式缓存服务器上的远程缓存： 使用集群方式，理论上可以做到不受限的缓存服务<br><img src="http://pztbc1npk.bkt.clouddn.com/arch3.png" alt="arch3"></li></ol><p>使用缓存后，数据访问压力得到有效缓解，但单一应用服务器能够处理的请求连接有限，在访问高峰期，<br>应用服务器成为性能瓶颈。</p><h3 id="4-使用应用服务器集群改善网站并发处理能力"><a href="#4-使用应用服务器集群改善网站并发处理能力" class="headerlink" title="4 使用应用服务器集群改善网站并发处理能力"></a>4 使用应用服务器集群改善网站并发处理能力</h3><p>使用集群是解决高并发、海量数据问题的常用手段。是可伸缩集群架构设计中较为简单成熟的一种。<br><img src="http://pztbc1npk.bkt.clouddn.com/arch4.png" alt="arch4"></p><p>通过负载均衡调度服务器，可将用户请求分发到应用服务器集群中的任何一台服务器上，使负载压力不再成为网站的瓶颈。</p><h3 id="5-数据库读写分离"><a href="#5-数据库读写分离" class="headerlink" title="5 数据库读写分离"></a>5 数据库读写分离</h3><p>缓存后，大部分数据读操作可以通过直接访问缓存，但仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写<br>操作需要访问数据库，一定规模后，数据库因负载压力过高而成为网站的瓶颈。</p><p>大部分主流数据库提供主从热备功能，通过主从关系可将一台数据库服务器数据同步到另一台机器，利用这一功能，<br>可以实现数据库读写分离，从而改善数据库负载压力<br><img src="http://pztbc1npk.bkt.clouddn.com/arch5.png" alt="arch5"></p><p>写数据时，访问主数据库，主数据库通过主从复制机制将数据同步到从数据库。读数据时，可以通过从数据库获得数据。<br>为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使读写分离对应用透明。</p><h3 id="6-使用反向代理和CDN加速"><a href="#6-使用反向代理和CDN加速" class="headerlink" title="6 使用反向代理和CDN加速"></a>6 使用反向代理和CDN加速</h3><p>由于网路的复杂性，不用地区访问速度差别很大。主要使用CDN和反向代理加速访问速度。<br>CDN和反向代理的基本原理都是缓存，区别在于CDN部署在ISP的机房，用户请求可从局里最近的机房获取数据；方向代<br>理部署在网站的中心机房，请求到达首先访问反向代理服务器，如果服务器中缓存着用户请求资源则直接返回。<br><img src="http://pztbc1npk.bkt.clouddn.com/arch6.png" alt="arch6"></p><p>使用CDN和反向代理可以一方面加快用户访问速度，另一方面减轻后端服务器的负载压力</p><h3 id="7-使用分布式文件系统和分布式数据库系统"><a href="#7-使用分布式文件系统和分布式数据库系统" class="headerlink" title="7 使用分布式文件系统和分布式数据库系统"></a>7 使用分布式文件系统和分布式数据库系统</h3><p>任何强大的单一服务器都满足不了持续增长的业务需求<br>数据库读写分离后拆分成两台服务器，随着业务发展依旧难以满足需求，这时，需要使用分布式数据库，文件系统也需<br>要使用分布式文件系统。<br><img src="http://pztbc1npk.bkt.clouddn.com/arch7.png" alt="arch7"></p><p>分布式数据库是数据库拆分的最后手段，常用的数据库拆分手段是业务分库，将不同业务的数据部署到不同的物理机。</p><h3 id="8-使用NoSQL和搜索引擎"><a href="#8-使用NoSQL和搜索引擎" class="headerlink" title="8 使用NoSQL和搜索引擎"></a>8 使用NoSQL和搜索引擎</h3><p><img src="http://pztbc1npk.bkt.clouddn.com/arch8.png" alt="arch8"><br>NoSQL和搜索引擎都是互联网的技术手段，对可伸缩的分布式特性具有更好的支持。<br>应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p><h3 id="9-业务拆分"><a href="#9-业务拆分" class="headerlink" title="9 业务拆分"></a>9 业务拆分</h3><p>大型网站为了应对日益复杂的业务场景，可以通过分而治之的手段将整个网站业务分成不同的产品线，分归不同的业务<br>团队负责。</p><p>具体到技术上，也会根据产品线划分，将一个网站拆分成不同的应用独立部署维护。应用之前可以通过超链接建立关系<br>，也可以通过消息队列进行数据分发，最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。<br><img src="http://pztbc1npk.bkt.clouddn.com/arch9.png" alt="arch9"></p><h3 id="10-分布式服务"><a href="#10-分布式服务" class="headerlink" title="10 分布式服务"></a>10 分布式服务</h3><p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。<br>在数万台服务器规模中，数据库系统连接数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。</p><p>每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些功用的业务提取出来<br>，独立部署。由这些可服用的业务连接数据库，提供共用业务服务，而应用系统只需管理用户界面，通过分布式服务调<br>用功用业务服务完成具体操作。<br><img src="http://pztbc1npk.bkt.clouddn.com/arch10.png" alt="arch10"></p><p>大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，侏儒跨数据中心的实时数据同步和具体业务相关的<br>问题也都可以通过组合改进现有技术架构来解决。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文道尽设计模式</title>
      <link href="/2019/11/12/%E4%B8%80%E6%96%87%E9%81%93%E5%B0%BD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/12/%E4%B8%80%E6%96%87%E9%81%93%E5%B0%BD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>简单讲，设计模式就是一些技术大师总结的一套写代码套路，不想回农村，学会套路深。</p><a id="more"></a><h3 id="学习设计模式从忘记模式开始"><a href="#学习设计模式从忘记模式开始" class="headerlink" title="学习设计模式从忘记模式开始"></a>学习设计模式从忘记模式开始</h3><p>设计模式分为三类：创建型、结构型、行为型</p><ul><li>创建型：创建对象使用</li><li>结构型：组织不同的小对象，形成更复杂结构的大对象</li><li>行为型：协调不同对象的运行流程</li></ul><p>使用设计模式的必要性？</p><p>面向对象的七大原则是评价一个设计模式好坏的标准。<br>1.开闭原则<br>2.里氏替换原则<br>3.依赖倒置原则<br>4.单一职责原则<br>5.接口隔离原则<br>6.迪米特原则<br>7.组合聚合复用原则</p><p>特别有节操的说明一点：设计模式不能强上<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>!</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>简单理解：创建型，控制创建对象数量，一次只能创建一个实例</p><p>必要性：特定场景下，若不适用单例，会导致同一时刻状态不同步；有利于节约系统资源；全局数据共享等</p><p>分类：</p><ol><li>饿汉式单例: 类一初始化，该类的对象就立刻会被实例化.</li></ol><p>简单实现：<br>    - private 修饰构造方法<br>    - static 修饰 instance，类加载阶段创建对象，利用只能被加载一次特点保证单例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>{} ❶</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();❷</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：如果创建对象耗时耗资源，会造成性能损耗</p><ol start="2"><li>懒汉式单例: 类一初始化，该类的对象就立刻会被实例化</li></ol><p>简单实现：<br>    - 类变量初始null，类加载不会立刻创建对象<br>    - 私有化构造方法<br>    - 判断是否已创建了对象，有创建不再创建，没有再创建，实现了延迟加载也保证了单例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;❶</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{❷</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>){ ❸</span><br><span class="line">      instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：多线程下，单例会被破坏</p><p>2-1. 使用加锁的方式避免多线程下，单例结构被破坏</p><p>简单实现：<br>    - volatile 保证多线程下的内存可见性<br>    - synchronized 同步锁保证同一时刻只有一个线程进入getInstance()方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;❶</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{ ❷</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">      instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：同步锁会导致线程阻塞，性能下降</p><p>2-2. 修改为双重检测锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{} </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>; ❷</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>{ ❶</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>){ ❸</span><br><span class="line">        <span class="keyword">synchronized</span> (LazySingleton.class) { ❺</span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="keyword">null</span>)❹</span><br><span class="line">          instance = <span class="keyword">new</span> LazySingleton();❻</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>静态内部类实现单例</li></ol><blockquote><p>根据类加载机制，外部类的初始化不会导致静态内部类的初始化</p></blockquote><p>简单实现：<br>    - 静态内部类创建实例，实现延迟加载<br>    - StaticInnerSingletonInstance.instance对instance引用创建对象一次，<br>      由于static 修饰只会在类接在初始化一次，天然保证线程安全。比几种方式优。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerSingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingletonInstance</span> </span>{ ❶</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerSingleton instance = <span class="keyword">new</span> StaticInnerSingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>{ ❷</span><br><span class="line">      <span class="keyword">return</span> StaticInnerSingletonInstance.instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>枚举实现</li></ol><blockquote><p>Java中的枚举类型本身就天然单例</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumSingletonInstance{</span><br><span class="line">   INSTANCE;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingletonInstance <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="keyword">return</span> INSTANCE;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：无法延迟加载，枚举类加载自然初始化实例</p><ol start="5"><li>破解？！单例</li></ol><blockquote><p>实现方式：反射、反序列化</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>最被广泛应用的设计模式——工厂模式</p><p>为什么需要工厂模式？</p><p>工厂模式属于创建型模式。顾名思义，工厂就是用来生产产品，例如汽车工厂，生产汽车;粮食工厂，生产粮食等。<br>在面向对象软件开发领域，自然是用这种模式来生产对象。</p><p>保证软件设计中的开闭原则不被违背，对扩展开发，对修改关闭。简言之，可以在已有代码基础上加入新的代码，但是<br>不允许修改写好的代码。</p><p>工厂模式相比直接使用new创建一个对象更利于解耦。因为new创建的对象一般都是具体的底层的一个对象 </p><blockquote><p>new操作本身就是一个耦合操作。</p></blockquote><p>例如：</p><p>解耦前：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>{</span><br><span class="line">    Dao dao = <span class="keyword">new</span> JpaDao(); ❶</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>{</span><br><span class="line">      <span class="comment">//使用dao进行一系列持久层操作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解耦后:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>{</span><br><span class="line">    Dao dao = DaoFactory.getDao(); ❶</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">//使用dao进行一系列持久层操作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dao <span class="title">getDao</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaDao(); ❷</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样优化后有一个明显好处，以后不管团队换啥持久层实现，所有的Service类是不需要再动了，<br>但是DaoFactory中的代码还是要修改，问题没有根本性解决，想完成解耦，必须拿掉new逻辑.<br>如何做？答案是：反射、配置方式，如下：</p><p>1) 创建config.properties文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao=com.example.demo.pattern.factory.JpaDao</span><br></pre></td></tr></tbody></table></figure><p>2) 修改 DaoFactory</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dao <span class="title">getDao</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.load(DaoFactory.class.getClassLoader().getResourceAsStream(<span class="string">"config.properties"</span>));</span><br><span class="line">        Class&lt;?&gt; dao = Class.forName((String) prop.get(<span class="string">"dao"</span>));</span><br><span class="line">        <span class="keyword">return</span> (Dao) dao.newInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>后续再要修改Dao实现方式，只需要提供对应的xxxDao类，并将其全类名配置在config.properties中即可。<br>所有的Service类中获取Dao的方式还是通过DaoFactory.getDao()，再也不需要修改了。</p><ol><li>简单工厂模式</li></ol><p>简单工厂模式是工厂模式的第一种形式，又叫静态工厂模式。顾名思义，因为这种工厂模式中获取对象的方法一般都定义成静态方法，形式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,P&gt; <span class="function">R <span class="title">getInstance</span><span class="params">(P type)</span></span>{</span><br><span class="line">        <span class="comment">//根据传入的type不同做if else判断返回不同类型的对象。</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,P&gt; <span class="function">R <span class="title">getInstance01</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//创建一种类型的对象</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,P&gt; <span class="function">R <span class="title">getInstance02</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//创建另一种类型的对象</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Best Ref: <a href="https://mp.weixin.qq.com/s/wb_INuq8cQ0p8hGtIYf0uQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wb_INuq8cQ0p8hGtIYf0uQ</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中注意使用合适的字段和字段长度</title>
      <link href="/2019/08/23/Mysql%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/"/>
      <url>/2019/08/23/Mysql%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>数据库设计中你所应知道的一些简单小事儿。</p><a id="more"></a><h3 id="记录中的常用信息"><a href="#记录中的常用信息" class="headerlink" title="记录中的常用信息"></a>记录中的常用信息</h3><p>下面是mysql创建一条记录时的常用重要信息，一般包含：名称、类型、长度、属性、非空、Zero填充、自增等<br>信息需要进行配置。</p><p><img src="http://pztbc1npk.bkt.clouddn.com/mysql2.png" alt="upload successful"></p><h3 id="字段类型选择"><a href="#字段类型选择" class="headerlink" title="字段类型选择"></a>字段类型选择</h3><p><img src="http://pztbc1npk.bkt.clouddn.com/mysql1.png" alt="upload successful"></p><p>字段类型有很多种，而常用的就那几种：</p><p>整数</p><p>1.这里需要注意的一点是整数型的数值类型已经限制了取值范围，分为有符号和无符号型，而Length（M）值并不代表可以存储的数值长度，它代表的是数据在显示时显示的最小长度</p><p>2.当存储的字符长度超过M值时，没有任何影响，只要不超过数值类型限制范围</p><p>3.当存储的字符长度小于M值时，只要在设置了ZeroFill，才有效果。</p><p>举个栗子：如果你设置int(11)，那么有个字段值是123，那么这个值在显示宽度上是3位，而设计的是显示的是11位，所以这时候，你如果在字段设计的时候，选择zerofill就可以发现，123变成了00000000123，也就是剩下的8位用0补足了。</p><p>所以我们在设计mysql数据库时，建表时，mysql会自动分配长度：int(11)、tinyint(4)、smallint(6)、mediumint(9)、bigint(20)。</p><blockquote><p>总结：就用这些默认的显示长度就可以了。不用再去自己填长度。比如搞个int(10)、tinyint(1)之类的，基本没用。而且导致表的字段类型多样化。</p></blockquote><p>字符类型</p><p>char(m)为固定长度</p><p>1.m取值为0～255，当保存char值时，在它们的右边填充空格以达到指定的长度。</p><p>2.当检索到char值时，尾部的空格被删除掉。</p><p>3.在存储或检索过程中不进行大小写转换。</p><p>char字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。</p><p>varchar(m)为可变长度类型</p><p>1.m取值为0~65535之间，保存时不进行填充。</p><p>2.varchar值保存时只保存需要的字符数，另加一个字节来记录长度（Length+1)。</p><p>3.当值保存和检索时尾部的空格仍保留，符合标准SQL。</p><p>varchar存储变长数据，但存储效率没有char高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为varchar(10)是最合算的。 从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点，所有当需要大量查询需求的时候，用char。当对于保存数据量过大的需求时，为了节省储存空间用varchar。</p><p>TEXT大文本</p><p>1.最大长度为65,535(2的16次方–1)字符的text列。</p><p>2.主要是用来存放非二进制的文本，如论坛帖子,题目，或者百度知道的问题和回答之类。</p><p>3.text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。</p><blockquote><p>总结：1.长度的区别，char范围是0～255，varchar最长是64k，如果遇到了大文本，考虑使用text，最大能到4G。<br>  2.效率来说基本是char&gt;varchar&gt;text。<br>  3.char和varchar可以有默认值，text不能指定默认值。</p></blockquote><p>时间类型</p><p>1.datetime类型 同时包含日期和时间信息的值时。Mysql检索并且以’YYYY-MM-DD HH:MM:SS’格式显示datetime值，支持的范围是’1000-01-01 00:00:00’到’9999-12-31 23:59:59’。可表示时间范围大。</p><p>2.date类型 仅需要日期值时，没有时间部分。MySQL检索并且以’YYYY-MM-DD’格式显示date值，<br>支持的范围是’1000-01-01’到’9999-12-31’。</p><p>3.timestamp类型 默认情况下，在 insert, update 数据时，timestamp 列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新,所占存储空间小。</p><p>4.time类型 表示一天中的时间。MySQL检索并且以”HH:MM:SS”格式显示time值。支持的范围是’00:00:00’到’23:59:59’。</p><h3 id="字段的索引及其设置"><a href="#字段的索引及其设置" class="headerlink" title="字段的索引及其设置"></a>字段的索引及其设置</h3><p>1.普通索引(index)：最基本的索引，没有任何限制。</p><p>2.唯一索引(unique)：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。</p><p>3.主键索引(primary)：它是一种特殊的唯一索引，提供唯一性约束，不允许有空值。</p><p>4.全文索引(fulltext)：仅可用于 MyISAM 表，用于在一篇文章中，检索文本信息的,针对较大的数据，生成全文索引很耗时耗空间。</p><blockquote><p>总结对索引的简单理解：如果你给一个唯一性的字段加上索引，比如一个字段是房间号。你不设置字段的情况下去搜索RoomNumber=101，那么数据库会去一条一条的搜索数据库中的RoomNumber字段，直到找到101给你返回，但如果你把RoomNumber设置为索引，那么数据库就会直接找到RoomNumber=101这条信息给你返回。所以索引的作用是加快数据库搜索的效率，但是同样的，你给一个字段设置为索引，是要消耗资源的。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
