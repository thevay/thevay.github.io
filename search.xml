<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java排坑指南(非公开版)</title>
      <link href="/2019/11/14/Java%E6%8E%92%E5%9D%91%E6%8C%87%E5%8D%97-%E9%9D%9E%E5%85%AC%E5%BC%80%E7%89%88/"/>
      <url>/2019/11/14/Java%E6%8E%92%E5%9D%91%E6%8C%87%E5%8D%97-%E9%9D%9E%E5%85%AC%E5%BC%80%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>这里记录一个排坑清单，我们没有必要纠结什么对，什么是错。但我们有必要知道什么是优，什么是劣。 </p><p>以下奉上满汉坑单一张（<strong>不定期更新排雷进度</strong>）</p><a id="more"></a><h3 id="1-尽量使用Collection-isEmpty-检测空"><a href="#1-尽量使用Collection-isEmpty-检测空" class="headerlink" title="1. 尽量使用Collection.isEmpty()检测空"></a>1. 尽量使用Collection.isEmpty()检测空</h3><p>使用Collection.size()来检测空在逻辑上没有问题，但是使用Collection.isEmpty()使得代码更易读，<br>并且可以获得更好的性能。</p><p>任何Collection.isEmpty()实现的时间复杂度都是O(1),但是某些Collection.size()实现的时间复杂度是O(n)。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(collection.size() == <span class="number">0</span>){}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(collection.isEmpty()){}</span><br></pre></td></tr></tbody></table></figure><p>判空：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CollectionUtils.isEmpty(collection)</span><br><span class="line">CollectionUtils.isNotEmpty(collection)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-集合初始化尽量指定大小"><a href="#2-集合初始化尽量指定大小" class="headerlink" title="2. 集合初始化尽量指定大小"></a>2. 集合初始化尽量指定大小</h3><p>Java 的集合类用起来十分方便，但是看源码可知，集合也是有大小限制的。每次扩容的时间复杂度很有可能是<br>O(n),所以尽量指定可预知的集合大小，能减少集合的扩容次数。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {</span><br><span class="line">    list.add(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(arr.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {</span><br><span class="line">    list.add(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-Tip-可以使用ONDUPLICATE-KEY-UPDATE-和唯一索引实现SQL批量插入更新操作"><a href="#3-Tip-可以使用ONDUPLICATE-KEY-UPDATE-和唯一索引实现SQL批量插入更新操作" class="headerlink" title="3. [Tip]可以使用ONDUPLICATE KEY UPDATE 和唯一索引实现SQL批量插入更新操作"></a>3. [Tip]可以使用ONDUPLICATE KEY UPDATE 和唯一索引实现SQL批量插入更新操作</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id="insertOrUpdateCameraInfoByOne" paramerType="com.pojo.AreaInfo"&gt;</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> camera_info( cameraId,zone1Id,zone1Name,zone2Id,zone2Name,zone3Id,zone3Name,zone4Id,zone4Name）</span><br><span class="line">    <span class="keyword">VALUES</span>(</span><br><span class="line">        <span class="comment">#{cameraId},#{zone1Id},#{zone1Name}, #{zone2Id},</span></span><br><span class="line">        <span class="comment">#{zone2Name}, #{zone3Id}, #{zone3Name},</span></span><br><span class="line">        <span class="comment">#{zone4Id}, #{zone4Name},)</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> </span><br><span class="line">    cameraId = <span class="keyword">VALUES</span>(cameraId),</span><br><span class="line">    zone1Id = <span class="keyword">VALUES</span>(zone1Id),zone1Name = <span class="keyword">VALUES</span>(zone1Name),</span><br><span class="line">    zone2Id = <span class="keyword">VALUES</span>(zone2Id),zone2Name = <span class="keyword">VALUES</span>(zone2Name),</span><br><span class="line">    zone3Id = <span class="keyword">VALUES</span>(zone3Id),zone3Name = <span class="keyword">VALUES</span>(zone3Name),</span><br><span class="line">    zone4Id = <span class="keyword">VALUES</span>(zone4Id),zone4Name = <span class="keyword">VALUES</span>(zone4Name)</span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="3-不要把集合对象传给自己"><a href="#3-不要把集合对象传给自己" class="headerlink" title="3. 不要把集合对象传给自己"></a>3. 不要把集合对象传给自己</h3><p>由于某些方法要求参数在执行期间保持不变，因此将集合传递给自身可能会导致异常行为。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br><span class="line">list.add(<span class="string">"World"</span>);</span><br><span class="line"><span class="keyword">if</span> (list.containsAll(list)) {}<span class="comment">// 无意义,总是返回true</span></span><br><span class="line">list.removeAll(list); <span class="comment">// 性能差, 直接使用clear()</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-字符串拼接使用-StringBuilder"><a href="#4-字符串拼接使用-StringBuilder" class="headerlink" title="4. 字符串拼接使用 StringBuilder"></a>4. 字符串拼接使用 StringBuilder</h3><p>一般的字符串拼接在编译期 java 会进行优化，但是在循环中字符串拼接， java 编译期无法做到<br>优化，所以需要使用 StringBuilder 进行替换。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">    s += i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line">String c = <span class="string">"c"</span>;</span><br><span class="line">String s = a + b + c; <span class="comment">// 没问题，java编译器会进行优化</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">    sb.append(i);  <span class="comment">// 循环中，java编译器无法进行优化，所以要手动使用StringBuilder</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-枚举的属性字段必须是私有不可变"><a href="#5-枚举的属性字段必须是私有不可变" class="headerlink" title="5. 枚举的属性字段必须是私有不可变"></a>5. 枚举的属性字段必须是私有不可变</h3><p>枚举通常被当做常量使用，如果枚举中存在公共属性字段或设置字段方法，那么这些枚举常量的属性很容易被修改。<br>理想情况下，枚举中的属性字段是私有的，并在私有构造函数中赋值，没有对应的 Setter 方法，最好加上 final 修饰符。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserStatus {</span><br><span class="line">    DISABLED(<span class="number">0</span>, <span class="string">"禁用"</span>),</span><br><span class="line">    ENABLED(<span class="number">1</span>, <span class="string">"启用"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserStatus</span><span class="params">(<span class="keyword">int</span> value, String description)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserStatus {</span><br><span class="line">    DISABLED(<span class="number">0</span>, <span class="string">"禁用"</span>),</span><br><span class="line">    ENABLED(<span class="number">1</span>, <span class="string">"启用"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserStatus</span><span class="params">(<span class="keyword">int</span> value, String description)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6-小心String-split-String-regex"><a href="#6-小心String-split-String-regex" class="headerlink" title="6. 小心String.split(String regex)"></a>6. 小心String.split(String regex)</h3><p>字符串 String 的 split 方法，传入的分隔字符串是<strong>正则表达式</strong>！部分关键字（比如.<a href=""></a>| 等）需要转义</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a.ab.abc"</span>.split(<span class="string">"."</span>); <span class="comment">// 结果为[]</span></span><br><span class="line"><span class="string">"a|ab|abc"</span>.split(<span class="string">"|"</span>); <span class="comment">// 结果为["a", "|", "a", "b", "|", "a", "b", "c"]</span></span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a.ab.abc"</span>.split(<span class="string">"\\."</span>); <span class="comment">// 结果为["a", "ab", "abc"]</span></span><br><span class="line"><span class="string">"a|ab|abc"</span>.split(<span class="string">"\\|"</span>); <span class="comment">// 结果为["a", "ab", "abc"]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="7-Tip-Java-9改进了String、StringBuffer、StringBuilder"><a href="#7-Tip-Java-9改进了String、StringBuffer、StringBuilder" class="headerlink" title="7. [Tip] Java 9改进了String、StringBuffer、StringBuilder"></a>7. [Tip] Java 9改进了String、StringBuffer、StringBuilder</h3><p>Java 提供String、StringBuffer、StingBuilder 封装字符串</p><p>String类是不可变类，String对象被创建后，包含在这个对象的字符序列不可改变</p><p>StringBuffer 对象代表一个字符序列可变的字符串，创建后通过append()、insert()等方法改变字符序列，最后调用<br>toString() 方法转换为String对象</p><p>StringBuilder也代表可变字符串对象，与StringBuffer区别在于StringBuffer线程安全，StringBuilder没有实现<br>线程安全，所以性能略高。</p><p>Java 9 改进了字符串的实现，之前使用char[] 保存字符，Java 9 改用Byte[]<strong>更加节省空间</strong>。</p><blockquote><p>字符串拼接原理：运行时,两个字符串str1,str2的拼接首先会调用 String.valueOf(obj),这个Obj为str1,而<br>String.valueOf(Obj)中的实现是return obj == null ? “null” : obj.toString(), 然后产生StringBuilder,调<br>用的StringBuilder(str1)构造方法,把StringBuilder初始化,长度为str1.length()+16,并且调用append(str1)！接<br>下来调用StringBuilder.append(str2)，把第二个字符串拼接进去,然后调用StringBuilder.toString返回结果！</p></blockquote><h3 id="8-需要-Map-的主键和取值时，应该迭代-entrySet"><a href="#8-需要-Map-的主键和取值时，应该迭代-entrySet" class="headerlink" title="8. 需要 Map 的主键和取值时，应该迭代 entrySet()"></a>8. 需要 Map 的主键和取值时，应该迭代 entrySet()</h3><p>当循环中只需要 Map 的主键时，迭代 keySet() 是正确的。<br>但是，当需要主键和取值时，迭代 entrySet() 才是更高效的做法，比先迭代 keySet() 后再去 get 取值性能更佳。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ...;</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) {</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ...;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="9-集合初始化尽量指定大小"><a href="#9-集合初始化尽量指定大小" class="headerlink" title="9. 集合初始化尽量指定大小"></a>9. 集合初始化尽量指定大小</h3><p>java 的集合类用起来十分方便，但是看源码可知，集合也是有大小限制的。<br>每次扩容的时间复杂度很有可能是 O(n) ，所以尽量指定可预知的集合大小，能减少集合的扩容次数。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {</span><br><span class="line">    list.add(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(arr.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {</span><br><span class="line">    list.add(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="10-List-的随机访问"><a href="#10-List-的随机访问" class="headerlink" title="10. List 的随机访问"></a>10. List 的随机访问</h3><p>大家都知道数组和链表的区别：数组的随机访问效率更高。</p><p>当调用方法获取到 List 后，如果想随机访问其中的数据，并不知道该数组内部实现是链表还是数组，怎么办呢？<br>可以判断它是否实现* RandomAccess 接口。</p><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用别人的服务获取到list</span></span><br><span class="line">List&lt;Integer&gt; list = otherService.getList();</span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) {</span><br><span class="line">    <span class="comment">// 内部数组实现，可以随机访问</span></span><br><span class="line">    System.out.println(list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 内部可能是链表实现，随机访问效率低</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="10-频繁调用-Collection-contains-方法请使用-Set"><a href="#10-频繁调用-Collection-contains-方法请使用-Set" class="headerlink" title="10. 频繁调用 Collection.contains 方法请使用 Set"></a>10. 频繁调用 Collection.contains 方法请使用 Set</h3><p>在 java 集合类库中，List 的 contains 方法普遍时间复杂度是 O(n)<br>如果在代码中需要频繁调用 contains 方法查找数据，可以先将 list 转换成 HashSet 实现，将 O(n) 的时间复杂度降为 O(1) 。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = otherService.getList();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) {</span><br><span class="line">    <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line">    list.contains(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = otherService.getList();</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet(list);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) {</span><br><span class="line">    <span class="comment">// 时间复杂度O(1)</span></span><br><span class="line">    set.contains(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="11-不要使用魔法值"><a href="#11-不要使用魔法值" class="headerlink" title="11. 不要使用魔法值"></a>11. 不要使用魔法值</h3><p>当你编写一段代码时，使用魔法值可能看起来很明确，但在调试时它们却不显得那么明确了。<br>这就是为什么需要把魔法值定义为可读取常量的原因。但是，-1、0 和 1不被视为魔法值</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++){</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">100</span>) {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i++){</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (count == MAX_COUNT) {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="12-建议使用-try-with-resources-语句"><a href="#12-建议使用-try-with-resources-语句" class="headerlink" title="12. 建议使用 try-with-resources 语句"></a>12. 建议使用 try-with-resources 语句</h3><p>Java 7 中引入了 try-with-resources 语句，该语句能保证将相关资源关闭，优于原来的 try-catch-finally 语句，并且使程序代码更安全更简洁。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String fileName)</span> </span>{</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        String line;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                reader.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                ...</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String fileName)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) {</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Ref: <a href="https://www.cnblogs.com/yueshutong/p/10725477.html" target="_blank" rel="noopener">https://www.cnblogs.com/yueshutong/p/10725477.html</a></p><h3 id="12-建议删除未使用的私有方法和字段"><a href="#12-建议删除未使用的私有方法和字段" class="headerlink" title="12. 建议删除未使用的私有方法和字段"></a>12. 建议删除未使用的私有方法和字段</h3><p>删除未使用的私有方法和字段，使代码更简洁更易维护。若有需要再使用，可以从历史提交中找回。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleDemo1</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> unusedField = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unusedMethod</span><span class="params">()</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleDemo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>代码膨胀是稍微有点规模的项目都会遇到的问题，在《人月神话》中也有提及。有规模的工程项目都是团队的产物，既然是团队的产物，<br>那么不可能不存在重复的代码，而这种重复的代码随着团队人员的增多，代码规模的增加会更加的突出。这是一个必然存在的问题，不<br>管是你的团队成员多么的优秀，规模的工程项目必然会存在，只不过是优秀的团队使得这种重复和混乱的增长速度变得小了而已。</p></blockquote><h3 id="13-工具类应该屏蔽构造函数"><a href="#13-工具类应该屏蔽构造函数" class="headerlink" title="13. 工具类应该屏蔽构造函数"></a>13. 工具类应该屏蔽构造函数</h3><p>工具类是一堆静态字段和函数的集合，不应该被实例化。但是，Java 为每个没有明确定义构造函数的类添加了一个隐式公有构造函数。<br>所以，为了避免 java “小白”使用有误，应该显式定义私有构造函数来屏蔽这个隐式公有构造函数。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>D;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>D;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MathUtils</span><span class="params">()</span> </span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="14-删除多余的异常捕获并抛出"><a href="#14-删除多余的异常捕获并抛出" class="headerlink" title="14. 删除多余的异常捕获并抛出"></a>14. 删除多余的异常捕获并抛出</h3><p>用 catch 语句捕获异常后，什么也不进行处理，就让异常重新抛出，这跟不捕获异常的效果一样，可以删除这块代码或添加别的处理。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) {</span><br><span class="line">        String line;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            builder.append(line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) {</span><br><span class="line">        String line;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            builder.append(line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="15-使用String-valueOf-value-代替””-value"><a href="#15-使用String-valueOf-value-代替””-value" class="headerlink" title="15. 使用String.valueOf(value)代替””+value"></a>15. 使用String.valueOf(value)代替””+value</h3><p>当要把其它对象或类型转化为字符串时，使用 String.valueOf(value) 比””+value 的效率更高。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">String s = <span class="string">""</span> + i;</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">String s = String.valueOf(i);</span><br></pre></td></tr></tbody></table></figure><h3 id="16-优先使用常量或确定值来调用-equals-方法"><a href="#16-优先使用常量或确定值来调用-equals-方法" class="headerlink" title="16. 优先使用常量或确定值来调用 equals 方法"></a>16. 优先使用常量或确定值来调用 equals 方法</h3><p>对象的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals 方法。当然，使用<br>java.util.Objects.equals() 方法是最佳实践。</p><p>反例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isFinished</span><span class="params">(OrderStatus status)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> status.equals(OrderStatus.FINISHED); <span class="comment">// 可能抛空指针异常</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isFinished</span><span class="params">(OrderStatus status)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> OrderStatus.FINISHED.equals(status);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isFinished</span><span class="params">(OrderStatus status)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(status, OrderStatus.FINISHED);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Best Ref: <a href="https://mp.weixin.qq.com/s/1aAwroGRSGWrzgE6XpPx7Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1aAwroGRSGWrzgE6XpPx7Q</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB架构演进之路</title>
      <link href="/2019/11/13/WEB%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/11/13/WEB%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB应用架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务调用幂等性实践</title>
      <link href="/2019/11/13/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/11/13/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 研发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂等性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文道尽设计模式</title>
      <link href="/2019/11/12/%E4%B8%80%E6%96%87%E9%81%93%E5%B0%BD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/12/%E4%B8%80%E6%96%87%E9%81%93%E5%B0%BD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="学习设计模式从忘记模式开始"><a href="#学习设计模式从忘记模式开始" class="headerlink" title="学习设计模式从忘记模式开始"></a>学习设计模式从忘记模式开始</h3><p>简单讲，设计模式就是一些技术大师总结的一套写代码套路，不想回农村，学会套路深。</p><a id="more"></a><p>设计模式分为三类：创建型、结构型、行为型</p><ul><li>创建型：创建对象使用</li><li>结构型：组织不同的小对象，形成更复杂结构的大对象</li><li>行为型：协调不同对象的运行流程</li></ul><p>使用设计模式的必要性？</p><p>面向对象的七大原则是评价一个设计模式好坏的标准。<br>1.开闭原则<br>2.里氏替换原则<br>3.依赖倒置原则<br>4.单一职责原则<br>5.接口隔离原则<br>6.迪米特原则<br>7.组合聚合复用原则</p><p>特别有节操的说明一点：设计模式不能强上<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>!</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>简单理解：创建型，控制创建对象数量，一次只能创建一个实例</p><p>必要性：特定场景下，若不适用单例，会导致同一时刻状态不同步；有利于节约系统资源；全局数据共享等</p><p>分类：</p><ol><li>饿汉式单例: 类一初始化，该类的对象就立刻会被实例化.</li></ol><p>简单实现：<br>    - private 修饰构造方法<br>    - static 修饰 instance，类加载阶段创建对象，利用只能被加载一次特点保证单例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>{} ❶</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();❷</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：如果创建对象耗时耗资源，会造成性能损耗</p><ol start="2"><li>懒汉式单例: 类一初始化，该类的对象就立刻会被实例化</li></ol><p>简单实现：<br>    - 类变量初始null，类加载不会立刻创建对象<br>    - 私有化构造方法<br>    - 判断是否已创建了对象，有创建不再创建，没有再创建，实现了延迟加载也保证了单例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;❶</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{❷</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>){ ❸</span><br><span class="line">      instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：多线程下，单例会被破坏</p><p>2-1. 使用加锁的方式避免多线程下，单例结构被破坏</p><p>简单实现：<br>    - volatile 保证多线程下的内存可见性<br>    - synchronized 同步锁保证同一时刻只有一个线程进入getInstance()方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;❶</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{ ❷</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">      instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：同步锁会导致线程阻塞，性能下降</p><p>2-2. 修改为双重检测锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{} </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>; ❷</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>{ ❶</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>){ ❸</span><br><span class="line">        <span class="keyword">synchronized</span> (LazySingleton.class) { ❺</span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="keyword">null</span>)❹</span><br><span class="line">          instance = <span class="keyword">new</span> LazySingleton();❻</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>静态内部类实现单例</li></ol><blockquote><p>根据类加载机制，外部类的初始化不会导致静态内部类的初始化</p></blockquote><p>简单实现：<br>    - 静态内部类创建实例，实现延迟加载<br>    - StaticInnerSingletonInstance.instance对instance引用创建对象一次，<br>      由于static 修饰只会在类接在初始化一次，天然保证线程安全。比几种方式优。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerSingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingletonInstance</span> </span>{ ❶</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerSingleton instance = <span class="keyword">new</span> StaticInnerSingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>{ ❷</span><br><span class="line">      <span class="keyword">return</span> StaticInnerSingletonInstance.instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>枚举实现</li></ol><blockquote><p>Java中的枚举类型本身就天然单例</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumSingletonInstance{</span><br><span class="line">   INSTANCE;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingletonInstance <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="keyword">return</span> INSTANCE;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：无法延迟加载，枚举类加载自然初始化实例</p><ol start="5"><li>破解？！单例</li></ol><blockquote><p>实现方式：反射、反序列化</p></blockquote><p>Best Ref: <a href="https://mp.weixin.qq.com/s/wb_INuq8cQ0p8hGtIYf0uQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wb_INuq8cQ0p8hGtIYf0uQ</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中注意使用合适的字段和字段长度</title>
      <link href="/2019/08/23/Mysql%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/"/>
      <url>/2019/08/23/Mysql%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="记录中的常用信息"><a href="#记录中的常用信息" class="headerlink" title="记录中的常用信息"></a>记录中的常用信息</h3><p>下面是mysql创建一条记录时的常用重要信息，一般包含：名称、类型、长度、属性、非空、Zero填充、自增等<br>信息需要进行配置。</p><a id="more"></a><p><img src="http://pztbc1npk.bkt.clouddn.com/mysql2.png" alt="upload successful"></p><h3 id="字段类型选择"><a href="#字段类型选择" class="headerlink" title="字段类型选择"></a>字段类型选择</h3><p><img src="http://pztbc1npk.bkt.clouddn.com/mysql1.png" alt="upload successful"></p><p>字段类型有很多种，而常用的就那几种：</p><p>整数</p><p>1.这里需要注意的一点是整数型的数值类型已经限制了取值范围，分为有符号和无符号型，而Length（M）值并不代表可以存储的数值长度，它代表的是数据在显示时显示的最小长度</p><p>2.当存储的字符长度超过M值时，没有任何影响，只要不超过数值类型限制范围</p><p>3.当存储的字符长度小于M值时，只要在设置了ZeroFill，才有效果。</p><p>举个栗子：如果你设置int(11)，那么有个字段值是123，那么这个值在显示宽度上是3位，而设计的是显示的是11位，所以这时候，你如果在字段设计的时候，选择zerofill就可以发现，123变成了00000000123，也就是剩下的8位用0补足了。</p><p>所以我们在设计mysql数据库时，建表时，mysql会自动分配长度：int(11)、tinyint(4)、smallint(6)、mediumint(9)、bigint(20)。</p><blockquote><p>总结：就用这些默认的显示长度就可以了。不用再去自己填长度。比如搞个int(10)、tinyint(1)之类的，基本没用。而且导致表的字段类型多样化。</p></blockquote><p>字符类型</p><p>char(m)为固定长度</p><p>1.m取值为0～255，当保存char值时，在它们的右边填充空格以达到指定的长度。</p><p>2.当检索到char值时，尾部的空格被删除掉。</p><p>3.在存储或检索过程中不进行大小写转换。</p><p>char字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。</p><p>varchar(m)为可变长度类型</p><p>1.m取值为0~65535之间，保存时不进行填充。</p><p>2.varchar值保存时只保存需要的字符数，另加一个字节来记录长度（Length+1)。</p><p>3.当值保存和检索时尾部的空格仍保留，符合标准SQL。</p><p>varchar存储变长数据，但存储效率没有char高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为varchar(10)是最合算的。 从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点，所有当需要大量查询需求的时候，用char。当对于保存数据量过大的需求时，为了节省储存空间用varchar。</p><p>TEXT大文本</p><p>1.最大长度为65,535(2的16次方–1)字符的text列。</p><p>2.主要是用来存放非二进制的文本，如论坛帖子,题目，或者百度知道的问题和回答之类。</p><p>3.text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。</p><blockquote><p>总结：1.长度的区别，char范围是0～255，varchar最长是64k，如果遇到了大文本，考虑使用text，最大能到4G。<br>  2.效率来说基本是char&gt;varchar&gt;text。<br>  3.char和varchar可以有默认值，text不能指定默认值。</p></blockquote><p>时间类型</p><p>1.datetime类型 同时包含日期和时间信息的值时。Mysql检索并且以’YYYY-MM-DD HH:MM:SS’格式显示datetime值，支持的范围是’1000-01-01 00:00:00’到’9999-12-31 23:59:59’。可表示时间范围大。</p><p>2.date类型 仅需要日期值时，没有时间部分。MySQL检索并且以’YYYY-MM-DD’格式显示date值，<br>支持的范围是’1000-01-01’到’9999-12-31’。</p><p>3.timestamp类型 默认情况下，在 insert, update 数据时，timestamp 列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新,所占存储空间小。</p><p>4.time类型 表示一天中的时间。MySQL检索并且以”HH:MM:SS”格式显示time值。支持的范围是’00:00:00’到’23:59:59’。</p><h3 id="字段的索引及其设置"><a href="#字段的索引及其设置" class="headerlink" title="字段的索引及其设置"></a>字段的索引及其设置</h3><p>1.普通索引(index)：最基本的索引，没有任何限制。</p><p>2.唯一索引(unique)：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。</p><p>3.主键索引(primary)：它是一种特殊的唯一索引，提供唯一性约束，不允许有空值。</p><p>4.全文索引(fulltext)：仅可用于 MyISAM 表，用于在一篇文章中，检索文本信息的,针对较大的数据，生成全文索引很耗时耗空间。</p><blockquote><p>总结对索引的简单理解：如果你给一个唯一性的字段加上索引，比如一个字段是房间号。你不设置字段的情况下去搜索RoomNumber=101，那么数据库会去一条一条的搜索数据库中的RoomNumber字段，直到找到101给你返回，但如果你把RoomNumber设置为索引，那么数据库就会直接找到RoomNumber=101这条信息给你返回。所以索引的作用是加快数据库搜索的效率，但是同样的，你给一个字段设置为索引，是要消耗资源的。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
