<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WEB架构演进之路</title>
      <link href="/2019/11/13/WEB%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/11/13/WEB%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB应用架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务调用幂等性实践</title>
      <link href="/2019/11/13/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/11/13/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 研发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂等性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文道尽设计模式</title>
      <link href="/2019/11/12/%E4%B8%80%E6%96%87%E9%81%93%E5%B0%BD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/12/%E4%B8%80%E6%96%87%E9%81%93%E5%B0%BD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="学习设计模式从忘记模式开始"><a href="#学习设计模式从忘记模式开始" class="headerlink" title="学习设计模式从忘记模式开始"></a>学习设计模式从忘记模式开始</h3><p>简单讲，设计模式就是一些技术大师总结的一套写代码套路，不想回农村，学会套路深。</p><a id="more"></a><p>设计模式分为三类：创建型、结构型、行为型</p><ul><li>创建型：创建对象使用</li><li>结构型：组织不同的小对象，形成更复杂结构的大对象</li><li>行为型：协调不同对象的运行流程</li></ul><p>使用设计模式的必要性？</p><p>面向对象的七大原则是评价一个设计模式好坏的标准。<br>1.开闭原则<br>2.里氏替换原则<br>3.依赖倒置原则<br>4.单一职责原则<br>5.接口隔离原则<br>6.迪米特原则<br>7.组合聚合复用原则</p><p>特别有节操的说明一点：设计模式不能强上<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>!</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>简单理解：创建型，控制创建对象数量，一次只能创建一个实例</p><p>必要性：特定场景下，若不适用单例，会导致同一时刻状态不同步；有利于节约系统资源；全局数据共享等</p><p>分类：</p><ol><li>饿汉式单例: 类一初始化，该类的对象就立刻会被实例化.</li></ol><p>简单实现：<br>    - private 修饰构造方法<br>    - static 修饰 instance，类加载阶段创建对象，利用只能被加载一次特点保证单例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>{} ❶</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();❷</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：如果创建对象耗时耗资源，会造成性能损耗</p><ol start="2"><li>懒汉式单例: 类一初始化，该类的对象就立刻会被实例化</li></ol><p>简单实现：<br>    - 类变量初始null，类加载不会立刻创建对象<br>    - 私有化构造方法<br>    - 判断是否已创建了对象，有创建不再创建，没有再创建，实现了延迟加载也保证了单例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;❶</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{❷</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>){ ❸</span><br><span class="line">      instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：多线程下，单例会被破坏</p><p>2-1. 使用加锁的方式避免多线程下，单例结构被破坏</p><p>简单实现：<br>    - volatile 保证多线程下的内存可见性<br>    - synchronized 同步锁保证同一时刻只有一个线程进入getInstance()方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;❶</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>{ ❷</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">      instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：同步锁会导致线程阻塞，性能下降</p><p>2-2. 修改为双重检测锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>{} </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>; ❷</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>{ ❶</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>){ ❸</span><br><span class="line">        <span class="keyword">synchronized</span> (LazySingleton.class) { ❺</span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="keyword">null</span>)❹</span><br><span class="line">          instance = <span class="keyword">new</span> LazySingleton();❻</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>静态内部类实现单例</li></ol><blockquote><p>根据类加载机制，外部类的初始化不会导致静态内部类的初始化</p></blockquote><p>简单实现：<br>    - 静态内部类创建实例，实现延迟加载<br>    - StaticInnerSingletonInstance.instance对instance引用创建对象一次，<br>      由于static 修饰只会在类接在初始化一次，天然保证线程安全。比几种方式优。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerSingleton</span><span class="params">()</span> </span>{}</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingletonInstance</span> </span>{ ❶</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerSingleton instance = <span class="keyword">new</span> StaticInnerSingleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>{ ❷</span><br><span class="line">      <span class="keyword">return</span> StaticInnerSingletonInstance.instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>枚举实现</li></ol><blockquote><p>Java中的枚举类型本身就天然单例</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumSingletonInstance{</span><br><span class="line">   INSTANCE;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingletonInstance <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="keyword">return</span> INSTANCE;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题：无法延迟加载，枚举类加载自然初始化实例</p><ol start="5"><li>破解？！单例</li></ol><blockquote><p>实现方式：反射、反序列化</p></blockquote><p>Best Ref: <a href="https://mp.weixin.qq.com/s/wb_INuq8cQ0p8hGtIYf0uQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wb_INuq8cQ0p8hGtIYf0uQ</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中注意使用合适的字段和字段长度</title>
      <link href="/2019/08/23/Mysql%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/"/>
      <url>/2019/08/23/Mysql%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="记录中的常用信息"><a href="#记录中的常用信息" class="headerlink" title="记录中的常用信息"></a>记录中的常用信息</h3><p>下面是mysql创建一条记录时的常用重要信息，一般包含：名称、类型、长度、属性、非空、Zero填充、自增等<br>信息需要进行配置。</p><a id="more"></a><p><img src="http://pztbc1npk.bkt.clouddn.com/mysql2.png" alt="upload successful"></p><h3 id="字段类型选择"><a href="#字段类型选择" class="headerlink" title="字段类型选择"></a>字段类型选择</h3><p><img src="http://pztbc1npk.bkt.clouddn.com/mysql1.png" alt="upload successful"></p><p>字段类型有很多种，而常用的就那几种：</p><p>整数</p><p>1.这里需要注意的一点是整数型的数值类型已经限制了取值范围，分为有符号和无符号型，而Length（M）值并不代表可以存储的数值长度，它代表的是数据在显示时显示的最小长度</p><p>2.当存储的字符长度超过M值时，没有任何影响，只要不超过数值类型限制范围</p><p>3.当存储的字符长度小于M值时，只要在设置了ZeroFill，才有效果。</p><p>举个栗子：如果你设置int(11)，那么有个字段值是123，那么这个值在显示宽度上是3位，而设计的是显示的是11位，所以这时候，你如果在字段设计的时候，选择zerofill就可以发现，123变成了00000000123，也就是剩下的8位用0补足了。</p><p>所以我们在设计mysql数据库时，建表时，mysql会自动分配长度：int(11)、tinyint(4)、smallint(6)、mediumint(9)、bigint(20)。</p><blockquote><p>总结：就用这些默认的显示长度就可以了。不用再去自己填长度。比如搞个int(10)、tinyint(1)之类的，基本没用。而且导致表的字段类型多样化。</p></blockquote><p>字符类型</p><p>char(m)为固定长度</p><p>1.m取值为0～255，当保存char值时，在它们的右边填充空格以达到指定的长度。</p><p>2.当检索到char值时，尾部的空格被删除掉。</p><p>3.在存储或检索过程中不进行大小写转换。</p><p>char字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。</p><p>varchar(m)为可变长度类型</p><p>1.m取值为0~65535之间，保存时不进行填充。</p><p>2.varchar值保存时只保存需要的字符数，另加一个字节来记录长度（Length+1)。</p><p>3.当值保存和检索时尾部的空格仍保留，符合标准SQL。</p><p>varchar存储变长数据，但存储效率没有char高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为varchar(10)是最合算的。 从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点，所有当需要大量查询需求的时候，用char。当对于保存数据量过大的需求时，为了节省储存空间用varchar。</p><p>TEXT大文本</p><p>1.最大长度为65,535(2的16次方–1)字符的text列。</p><p>2.主要是用来存放非二进制的文本，如论坛帖子,题目，或者百度知道的问题和回答之类。</p><p>3.text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。</p><blockquote><p>总结：1.长度的区别，char范围是0～255，varchar最长是64k，如果遇到了大文本，考虑使用text，最大能到4G。<br>  2.效率来说基本是char&gt;varchar&gt;text。<br>  3.char和varchar可以有默认值，text不能指定默认值。</p></blockquote><p>时间类型</p><p>1.datetime类型 同时包含日期和时间信息的值时。Mysql检索并且以’YYYY-MM-DD HH:MM:SS’格式显示datetime值，支持的范围是’1000-01-01 00:00:00’到’9999-12-31 23:59:59’。可表示时间范围大。</p><p>2.date类型 仅需要日期值时，没有时间部分。MySQL检索并且以’YYYY-MM-DD’格式显示date值，<br>支持的范围是’1000-01-01’到’9999-12-31’。</p><p>3.timestamp类型 默认情况下，在 insert, update 数据时，timestamp 列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新,所占存储空间小。</p><p>4.time类型 表示一天中的时间。MySQL检索并且以”HH:MM:SS”格式显示time值。支持的范围是’00:00:00’到’23:59:59’。</p><h3 id="字段的索引及其设置"><a href="#字段的索引及其设置" class="headerlink" title="字段的索引及其设置"></a>字段的索引及其设置</h3><p>1.普通索引(index)：最基本的索引，没有任何限制。</p><p>2.唯一索引(unique)：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。</p><p>3.主键索引(primary)：它是一种特殊的唯一索引，提供唯一性约束，不允许有空值。</p><p>4.全文索引(fulltext)：仅可用于 MyISAM 表，用于在一篇文章中，检索文本信息的,针对较大的数据，生成全文索引很耗时耗空间。</p><blockquote><p>总结对索引的简单理解：如果你给一个唯一性的字段加上索引，比如一个字段是房间号。你不设置字段的情况下去搜索RoomNumber=101，那么数据库会去一条一条的搜索数据库中的RoomNumber字段，直到找到101给你返回，但如果你把RoomNumber设置为索引，那么数据库就会直接找到RoomNumber=101这条信息给你返回。所以索引的作用是加快数据库搜索的效率，但是同样的，你给一个字段设置为索引，是要消耗资源的。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
